if CLIENT then return end

print( "SERVER" )

local function doIncludes( incs, callback )
    local included = 0
    if #incs == 0 then
        callback()
    else
        local function recursiveInclude()
            include( incs[ included + 1 ], function()
                included = included + 1
                if included == #incs then
                    callback()
                else
                    recursiveInclude()
                end
            end )
        end
        recursiveInclude()
    end
end

function NAB.core.preInit ( ply )
    local includes = {
        NAB.lib .. "search.lua.txt",
    }

    doIncludes( includes, function()
        if not NAB.UID then
            find.add( Vector( -20.626, 0.031, -2.703 ), "models/cheeze/wires/mini_cpu.mdl", "gmod_wire_value", chip(), function( ent )
                if ent:wirelink() then
                    NAB.UID = ent:wirelink()[ "1" ]
                    print( "Found UID chip: " .. NAB.UID )

                    NAB.core.init( ply )
                else
                    print( "Failed to find UID chip" )
                end
            end )
        else
            NAB.core.init( ply )
        end
    end )
end

function NAB.core.init ( ply )
    local includes = {
        NAB.bin .. "sv/chat.lua.txt",
        NAB.bin .. "sv/provider.lua.txt",
        NAB.bin .. "sv/entity.lua.txt",
    }

    doIncludes( includes, function ()
        net.send( "[sv:nab_net] core.preInit", { UID = NAB.UID }, ply )
        --WAIT FOR CLIENT TO BE READY

        net.receive( "[cl:nab_net] core.init", function ( name, data, ply )
            net.remove( "[cl:nab_net] core.init" )

            net.send( "[sv:nab_net] core.init", nil, ply )
            NAB.core.postInit( ply )
        end )

        net.send( "[sv:nab_net] core.init", nil, ply )
    end )
end

function NAB.core.postInit ( ply )
    local includes = {

    }

    doIncludes( includes, function ()
        local chipEnt = NAB.Entity( "chip", chip(), nil )

        net.receive( "[cl:nab_net] core.vehiclejson", function( name, data, ply )
            NAB.vehicle = data

            local function createFromTable( entData, parent )
                for k, v in pairs( entData ) do
                    find.add( Vector( v.pos[ 1 ], v.pos[ 2 ], v.pos[ 3 ] ), v.model, v.class, parent.ent, function( ent )
                        local newEnt = NAB.Entity( k, ent, parent )
                        print( "Created " .. newEnt:__tostring() )
                        --Create providers
                        for _k, _v in pairs( v.providers ) do
                            local providerClass = NAB.Provider[ _v.type ]
                            if providerClass then
                                local provider = NAB.Provider[ _v.type ]( _k, _v )
                                print( "\tAdded '" .. provider.type .. "' provider" )
                                newEnt:addProvider( provider )
                            else
                                print( "\tFailed to add '" .. _v.type .. "' provider" )
                            end
                        end

                        --Create child entities
                        createFromTable( v.children, newEnt )
                    end )
                end
            end

            createFromTable( NAB.vehicle, chipEnt )
        end )

        --LOAD ENTITIES AND PROVIDERS

    end )
end


